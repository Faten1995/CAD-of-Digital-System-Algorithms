
import matplotlib.pyplot as plt
from scipy import stats
import numpy as np
import time
import random
import math
from typing import List, Optional, Callable, Tuple
from random import choices, randint, randrange, random

start_time = time.time()

#Vertix class
class Vertex:
    # id, edges, partition_label
    def __init__(self, id):
        self.id = id
        self.edges = []

    def add_edge(self, edge):
        # undirected graph, ignore reverse direction
        for present_edge in self.edges:
            if present_edge.left_id == edge.right_id and present_edge.right_id == edge.left_id:
                return
        self.edges.append(edge)

#Edge class
class Edge:
    # left_id, right_id, left_v, right_v
    def __init__(self, left_id, right_id, cost):
        self.left_id = left_id
        self.right_id = right_id
        self.cost = cost

#Graph class
class Graph:
    # vertices, edges
    def __init__(self, vertices, edges):
        self.vertices = vertices
        self.edges = edges


        # connect vertices and edges
        vertex_dict = {v.id: v for v in self.vertices}

        for edge in self.edges:
            edge.left_v = vertex_dict[edge.left_id]
            vertex_dict[edge.left_id].add_edge(edge)

            edge.right_v = vertex_dict[edge.right_id]
            vertex_dict[edge.right_id].add_edge(edge)

    def get_partition_cost(self):
        cost = 0

        for edge in self.edges:
            if edge.left_v.partition_label != edge.right_v.partition_label:
                cost += edge.cost
        return cost


class Genetic_Algorithm:
    #For the final diagram
    average_cost_of_population =  []
    generation = []
    population = []
    def __init__(self, graph, Psize, Ng, No, benalty, fitness_limit):
        self.graph = graph
        self.Psize = Psize #Population Size, number of any possible solutions at a population
        self.Ng = Ng #Number of Generation, #of iterations
        self.No = No #Number of Offsprings, to be generated by cross-over
        self.benalty = benalty #Imbalance Benalty should be from 0 to 1
        self.fitness_limit = fitness_limit
        #self.Mr = Mr #Mutation probability, Mutation Rate

        print("Genetic Algorithm Heuristic - Bi-partitioning Problem")
        print("Heuristic Parameters:")
        print("Population size (Psize): " + str(self.Psize))
        print("Number of Generations (Ng): " + str(self.Ng))
        print("Number of Offsprings (No): " + str(self.No))

        population, generation = self.evolution()

        print("---------Final Generation---------")
        self.printer(population, generation)
        # print("-------Sorted Population---------")
        # for i in range(len(p)):
        #     print(str(p[i]))

        #Plot fitness vs generation
        x = np.array(self.generation)
        y = np.array(self.average_cost_of_population) # x is a numpy array now
        plt.plot(x, y)
        # naming the x axis
        plt.xlabel('x - Generation')
        # naming the y axis
        plt.ylabel('y - Average Fitness')
        # giving a title to my graph
        plt.title('Fitness vs Generation!')
        plt.show()

#Function to Generate Population
    def generate_population(self, size):
        population = []
        for i in range(size):
            c = self.generate_chromosome(len(self.graph.vertices))
            population.append(c)
        return population

#Function to Generate Chromosome / Genome
    def generate_chromosome(self, length):
        chromosome = []
        for i in range(length):
            c = randint(0, 1)
            chromosome.append(c)
            # if len(chromosome) < int(length)//2:
            #     c = randint(0, 1)
            #     chromosome.append(c)
            #     print(np.count_nonzero(chromosome))
            # elif np.count_nonzero(chromosome) == int(length)//4:
            #     c = randint(0, 1)
            #     chromosome.append(c)
            #     print(np.count_nonzero(chromosome))
            # elif np.count_nonzero(chromosome) <= int(length)//4:
            #     c = 1
            #     chromosome.append(c)
            #     print(np.count_nonzero(chromosome))
            # else :
            #     c = 0
            #     chromosome.append(c)
        return chromosome

#Function to evaluate Fitness, it should consider two Elements
# 1- Partition Cost
# 2- Partition Balance/Imbalanace
    def fitness(self, chromosome):

        cost = 0
        #Calculate the Partition Cost
        for i in range(len(chromosome)):
            if chromosome[i] == 0:
                self.graph.vertices[i].partition_label = "A"
            else:
                self.graph.vertices[i].partition_label = "B"
        cost += self.graph.get_partition_cost()



        #Calculate the Balance/Imbalance Cost with High Benalty
            #np.count_nonzero(chromosome) gives the number of 1s
            #if number of 1s is greater than half of the graph length then we calculate Benalty
        correctCount = len(self.graph.vertices)//2
        count1 = np.count_nonzero(chromosome)
        if count1 == correctCount:
            #Partition is balanced
            cost += 0
        else:
            #Calculate the Benalty
            x = abs(count1 - correctCount)
            y = int(self.benalty * x)
            cost += y

        return cost

#Function to Evaluate the average fitness of a Population
    def evaluate(self, population):

        fitness = 0
        total = 0
        for i in range(len(population)):
            #Evaluate the Fitness for each chromosome
            total += self.fitness(population[i])
        fitness = int(total/len(population))
        print("average fitness of the population is: " + str(fitness))
        return fitness

#Function to select a pair of chromosomes for Cut-Catenate crossover
    def select_pair(self, population):

        return choices(
        population=population,
        weights=[self.fitness(chromosome) for chromosome in population],
        k=2)

#Function for Cut-Catenate Crossover  Function
    def crossover(self, chromosomePair):
        a = chromosomePair[0]
        b = chromosomePair[1]
        if len(a) != len(b):
            print("inside error")
            raise ValueError("Chromosome a and b must be of same length")

        length = len(a)
        if length < 2:
            print("inside length <  2")
            #No benefit of cross-over
            return chromosomePair

        p = randint(1, length - 1)
        #print("p value is: " + str(p))
        nodeA = a[0:p] + b[p:]
        #print("Node A: " + str(nodeA))
        nodeB = b[0:p] + a[p:]
        #print("Node B: " + str(nodeA))
        return nodeA, nodeB

#Function to run Evolution
    def evolution(self):
        fitnessLimit = self.fitness_limit
        generationsLimit = self.Ng

        #Construct Initial Population:
        p = self.generate_population(self.Psize)


        #p = sorted(p, key=lambda genome: self.fitness(genome), reverse=True)
        #Print Initial Population:
        #check this!
        for i in range(len(p)):
            print(str(p[i]))


        #Evaluate the fitness of the Population

        #Loop for Generation Limit, going through all Generations
        for i in range(generationsLimit):
            #Sort population by Fitness
            #p = self.sort_population(p)


            p = sorted(p, key=lambda genome: self.fitness(genome), reverse=False)
            #sorted(p, key=lambda chromosome: self.fitness(chromosome), reverse=False)
            self.printer(p, i)
            self.generation.append(i)
            self.population.append(p)
            self.average_cost_of_population.append(self.evaluate(p))

            #check if we reached the fitness Limit
            if self.fitness(p[0]) <= fitnessLimit:
                print("BREAK!!!!")
                break

            #take the best 2 chromosomes to the next generation
            next_generation = p[0:2]

            #Children generation - 4 which are the two already selected parents
            for j in range(int(len(p)/2) - 1):
                parents = self.select_pair(p)
                nodeA, nodeB = self.crossover(parents)
                next_generation.append(nodeA)
                next_generation.append(nodeB)

            p = next_generation

        #end of the for loop


        #
        # print("Selected pair: " + str(pair))
        # print("Cross-over pair:" + str(newPair))

        return p, i

    def printer(self, population, generation_id):
        print("GENERATION %02d" % generation_id)
        print("=============")
        print("Population: [%s]" % ", ".join([self.genome_to_string(chromosome) for chromosome in population]))
        print("Avg. Fitness: %f" % (self.evaluate(population)))
        sorted_population = self.sort_population(population)
        print(
            "Best: %s (%f)" % (self.genome_to_string(sorted_population[0]), self.fitness(sorted_population[0])))
        print("Worst: %s (%f)" % (self.genome_to_string(sorted_population[-1]),
                                  self.fitness(sorted_population[-1])))
        print("")

        return sorted_population[0]

    def genome_to_string(self, chromosome):
        return str(chromosome)

    def sort_population(self, p):
        return sorted(p, key=lambda chromosome: self.fitness(chromosome), reverse=False)
#Main function
def main():
    graph = load_data("/Users/faten/Documents/Genetic_Algorithm/10by10withCost.txt")
    #kl = KernighanLin(graph)
    #kl.partition()

    #Parameters List
    #graph
    #population size
    #number of generations
    #number of offsprings
    #benalty
    #fitness limit
    ga = Genetic_Algorithm(graph, 20, 1000, 20, 10, 5)


#Function to load data
def load_data(filename):
    file = open(filename, 'r')
    #file = open("/Users/faten/Documents/Genetic_Algorithm/2by2withCost.txt")

    edges = []
    vertices = []
    seen_vertex_ids = []

    for line in list(file):
        v_list = line.split()
        left_id = int(v_list[0])
        right_id = int(v_list[1])
        cost_id = int(v_list[2])
        edges.append(Edge(left_id, right_id, cost_id))

        if left_id not in seen_vertex_ids:
            vertices.append(Vertex(left_id))
            seen_vertex_ids.append(left_id)

        if right_id not in seen_vertex_ids:
            vertices.append(Vertex(right_id))
            seen_vertex_ids.append(right_id)

    return Graph(vertices, edges)

#Start the application
if __name__ == "__main__":
    main()
